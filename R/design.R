#' @title Design specification for simulating datasets
#'
#' @description
#' Stores information necessary to simulate and visualize datasets based
#' on multivariate normal distribution Z.
#'
#' @param relations
#' Correlation / Covariance matrix of the initial multivariate
#' gaussian distribution Z.
#' @param transform
#' List of functions. Specifies transformation of underlying
#' datamatrix Z to final datamatrix X. If not specified, identity transforms
#' are assumed. If named list, \code{names(transform)} will be used
#' for columnnames of X by \code{\link{simulate_data}}.
#' @param transform_type
#' Optional vector of length equal to \code{transform} and hence number of
#' columns of final datamatrix X. Allowed entries are "logical", "factor" and
#' "numeric". Stores the intented output type of the transformation function
#' corresponding to a specific column of X and hence the type of the column
#' of X. Useful for plotting and proper data handling. If not specified by
#' user, inferred by applying the functions to a test matrix (all 0s,
#' columns as specified by \code{relations}).
#' @param mean_initial
#' Vector of mean values of the initial multivariate gaussian
#' distribution Z. Dimension needs to correspond to dimension
#' of \code{relations}.
#' @param sd_initial
#' Vector of standard deviations of the initial multivariate
#' gaussian distribution Z. Dimension needs to correspond to dimension
#' of \code{relations}. Overriden by suqare root of diagonal elements of
#' \code{relations} if \code{is_correlation} is FALSE.
#' @param is_correlation
#' If TRUE, then \code{relations} specifies a correlation matrix (default,
#' this type of specification is usually more natural than specifying
#' a covariance matrix). Otherwise, \code{relations} specifies a
#' covariance matrix whose square root diagonal elements override
#' \code{sd_initial}.
#' @param truncate_final
#' Vector of truncation parameters. Either a single value which is
#' replicated as necessaary or of same dimension as \code{ncol(x)}.
#' If any vector entry is NA, the corresponding column will not be
#' truncated. See \code{\link{truncate}}.
#' @param names_final
#' Variable names for final datamatrix X. Needs to have same
#' dimension as \code{transform}. Overrides other naming options.
#' @param prefix_final
#' Prefix attached to variables in final datamatrix X. Overriden
#' by \code{names} argument or using a named list for \code{transform}.
#' @param process_final
#' List of lists. Applies post-processing to final datamatrix X after
#' pre-implemented post-processing (such as truncation). See
#' \code{\link{process_data}} for details on the specification. Usually
#' this argument is not necessary and should be used with caution.
#'
#' @details
#' The \code{design} class should be used in the following workflow:
#'
#' \enumerate{
#' \item Specify a design template which will be used in subsequent data
#' generating / visualization steps.
#' \item Sample / visualize datamatrix following template (possibly
#'  multiple times).
#' \item Use sampled datamatrix to obtain simulation results.
#' }
#'
#' @section Data Generation:
#' In step 2) data is generated by \code{\link{simulate_data}} using the
#' following procedure:
#' \enumerate{
#' \item The underlying data matrix Z is sampled from a
#' multivariate gaussian distribution (number of dimensions specified by
#' dimensions of \code{relations}).
#' \item Z is then transformed into the final data matrix X by applying
#' functions from \code{transform} to the columns of Z (final number of
#' variables given by length of \code{transform}).
#' \item X is post-processed if specified (truncation to avoid
#' outliers).
#' }
#'
#' Transformations are specified as a list of functions, which take
#' the whole datamatrix Z as single argument. For example, to multiply
#' column 2 of Z by 2, use function(Z) Z[,2] * 2.
#'
#' @section Truncation:
#' Truncation is a pre-implemented, useful post-processing step to prevent
#' outliers which may influence model results and give weird simulation
#' output. It is conducted as described in \code{\link{truncate}}.
#'
#' @section Post-processing (\code{process_final}):
#' Post-processing is applied to the final datamatrix X after pre-implemented
#' post-processing (truncation). For details see \code{\link{process_data}}.
#' Note that beside simple processing such as truncation, it is usually
#' advisable to not do post-processing directly in the simulation process,
#' but only once a dataset has been finalized and is ready for the subsequent
#' steps. \code{\link{process_data}} can then be used to quickly
#' implement several processing steps as well.
#'
#' @note
#' Note that \code{relations} specifies the correlation / covariance
#' of the underlying gaussian data Z and thus does not directly translate into
#' correlations between the variables of the final datamatrix X.
#'
#' @return
#' List object with class attribute "design" (S3 class) containing
#' the following entries (if no further information given, entries are
#' directly saved from user input):
#'
#' \describe{
#' \item{\code{cor_initial}}{Correlation matrix of initial multivariate
#' gaussian distribution Z.}
#' \item{\code{transform}}{}
#' \item{\code{transform_type}}{}
#' \item{\code{mean_initial}}{}
#' \item{\code{sd_initial}}{}
#' \item{\code{process_final}}{}
#' \item{\code{names_final}}{Columnnames of final datamatrix X.}
#' }
#'
#' @seealso
#' \code{\link{simulate_data}}, \code{\link{conditional_simulate_data}}
#'
#' @export
design <- function(relations,
                   transform = NULL,
                   transform_type = NULL,
                   mean_initial = rep(0, nrow(relations)),
                   sd_initial = rep(1, nrow(relations)),
                   is_correlation = TRUE,
                   truncate_final = NULL,
                   names_final = NULL,
                   prefix_final = "v",
                   process_final = list()) {

    design = list(cor_initial = relations,
                  transform = transform,
                  transform_type = transform_type,
                  mean_initial = mean_initial,
                  sd_initial = sd_initial,
                  names_final = names_final,
                  process_final = list())

    if (!is_correlation) {
        design$sd_initial = sqrt(diag(relations))
        design$cor_initial = (1 / design$sd$initial) %*%
            relations %*% (1 / design$sd$initial)
    }

    if (is.null(transform)) {
        # default is no transformation at all
        design$transform = sapply(1:nrow(relations),
                           function(i) {
                               return(list(function(x) x[, i]))
                           })
    }

    # infer transform type by applying to test data
    if (is.null(transform_type)) {
        test_z = matrix(0, ncol = ncol(design$cor_initial))
        design$transform_type = sapply(design$transform,
                                       function(f) class(f(test_z)))
    }

    # if names is null, then give default names, if it is a char array
    # use accordingly
    if (is.null(names_final)) {
        if (!is.null(names(transform))) {
            design$names_final = names(transform)
        } else design$names_final = paste0(prefix_final,
                                           seq_along(design$transform))
    }

    # build post-processing calls, first pre-implemented options
    # truncation
    if (!is.null(truncate_final))
        design$process_final = modifyList(design$process_final,
                                         list("truncate" =
                                                  list(truncate_multipliers = truncate_final)))
    # further, user specified functions to be added
    design$process_final = modifyList(design$process_final, process_final)

    class(design) = "design"

    return(design)
}
